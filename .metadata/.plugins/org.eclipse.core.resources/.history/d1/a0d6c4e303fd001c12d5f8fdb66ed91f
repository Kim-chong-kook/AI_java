package kr.co.tj;

import java.math.BigInteger;

public class BinaryTest {
	public static void main(String[] args) {
		int num  = 10;
		int bNum = 0B1010;
		int oNum = 012;
		int xNum = 0XA;
		
		System.out.println(num);
		System.out.println(bNum);
		System.out.println(oNum);
		System.out.println(xNum);
		
		byte b = 128; // 127까지만, 해결책은 범위맞게 넣는다.
		byte b1 = -128; // 1byte의 범위인 -128~127의 범위를 넘으면 에러상태. 
		long l1 = 1_000_000_000_000_000L; // 숫자는 기본 int로 21억 이내로 받으므로 에러(long 최대 1천조는 범위 오버이므로 l을 붙여준다.)
		long l2 = 1_000000000000_000_000_000_000L; // l을 써줘도 천조를 넘어 오버에러.
		BigInteger l3 = new BigInteger("10000000000000000000000000000");
		float f = 3.141592; // 4byte 유형이 맞지 않는다.
		float f1 = 3.141592F; // 4byte, F를 써준다.
		double d = 3.141592; // 실수기본형 : 8byte 
		// ■ ■ ■ 이러한 문제의 근본은 변수의 기본형이 존재해 pc가 그냥 기본형으로 받아들이기 때문에 굳이 memory를 절약하려면, 뒤에 l과 f를 써줘야 한다. 
	
	
	
	
	}

}
